package controllers

import (
	"context"
	"reflect"
	"time"

	appv1 "github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1"
	"github.com/go-logr/logr"
	"github.com/redhat-appstudio/managed-gitops/backend-shared/config/db"
	sharedutil "github.com/redhat-appstudio/managed-gitops/backend-shared/util"
	apierr "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/yaml"
)

const (
	WaitForArgoCDToPerformFinalizerDeleteTimeout    = time.Minute * 5
	WaitForArgoCDToPerformNonfinalizerDeleteTimeout = time.Minute * 2
)

const (
	argoCDResourcesFinalizer = "resources-finalizer.argocd.argoproj.io/background"
)

const (
	// ArgoCDApplicationDatabaseIDLabel is the label that is added to Argo CD Applications generated by cluster-agent's Operation controller
	ArgoCDClusterSecretDatabaseIDLabel = "databaseID"
	ArgoCDApplicationDatabaseIDLabel   = "databaseID"
	RepoCredDatabaseIDLabel            = "databaseID"
)

// DeleteArgoCDApplication attempts to gracefully delete an Argo CD application:
// - Issue a Delete to K8s API
// - If the Application is not deleted after X minutes, remove the finalizer
// - If the Application is not deleted after X+2 minutes, return an error
func DeleteArgoCDApplication(ctx context.Context, appFromList appv1.Application, eventClient client.Client, log logr.Logger) error {

	log = log.WithValues("name", appFromList.Name, "namespace", appFromList.Namespace, "uid", string(appFromList.UID))

	log.Info("Attempting to delete Argo CD Application CR")

	app := &appv1.Application{
		ObjectMeta: metav1.ObjectMeta{
			Name:      appFromList.Name,
			Namespace: appFromList.Namespace,
		},
	}

	if err := eventClient.Get(ctx, client.ObjectKeyFromObject(app), app); err != nil {

		if apierr.IsNotFound(err) {
			// The Application no longer exists: no work to do.
			return nil
		}

		log.Error(err, "Unable to retrieve Argo CD Application which we are attempting to delete")
		return err
	}

	if value, exists := app.Labels[ArgoCDApplicationDatabaseIDLabel]; !exists || value == "" {
		log.V(sharedutil.LogLevel_Debug).Info("skipping non-GitOps Service application")
		return nil
	}

	if app.DeletionTimestamp == nil {

		// Ensure finalizer is set
		{
			containsFinalizer := false
			for _, finalizer := range app.Finalizers {
				if finalizer == argoCDResourcesFinalizer {
					containsFinalizer = true
					break
				}
			}

			if !containsFinalizer {
				app.Finalizers = append(app.Finalizers, argoCDResourcesFinalizer)
				if err := eventClient.Update(ctx, app); err != nil {
					log.Error(err, "unable to update application with finalizer")
					return err
				}
				sharedutil.LogAPIResourceChangeEvent(app.Namespace, app.Name, app, sharedutil.ResourceModified, log)

			}
		}

		// Tell K8s to start deleting the Application, which triggers Argo CD to delete children
		policy := metav1.DeletePropagationForeground
		if err := eventClient.Delete(ctx, app, &client.DeleteOptions{PropagationPolicy: &policy}); err != nil {
			log.Error(err, "unable to delete application with finalizer")
			return err
		}
		sharedutil.LogAPIResourceChangeEvent(app.Namespace, app.Name, app, sharedutil.ResourceDeleted, log)

	}

	backoff := sharedutil.ExponentialBackoff{
		Factor: 2,
		Min:    time.Millisecond * 200,
		Max:    time.Second * 10,
		Jitter: true,
	}

	// Wait for Argo CD to delete the application.
	// We wait either (now+5 minutes), or (deletionTimestamp+5 minutes), whichever is soonest.
	success := false
	var expirationTime time.Time
	if app.DeletionTimestamp == nil {
		expirationTime = time.Now().Add(WaitForArgoCDToPerformFinalizerDeleteTimeout) // wait X minutes for Argo CD to delete
	} else {
		expirationTime = app.DeletionTimestamp.Time.Add(WaitForArgoCDToPerformFinalizerDeleteTimeout)
	}

	for {

		if time.Now().After(expirationTime) {
			log.V(sharedutil.LogLevel_Warn).Error(nil, "Argo CD application finalizer-based delete expired in deleteArgoCDApplication")
			break
		}

		if err := eventClient.Get(ctx, client.ObjectKeyFromObject(app), app); err != nil {

			if apierr.IsNotFound(err) {
				log.Info("The Argo CD application has been successfully deleted.")
				success = true
				// Success! The Application (and its resources) have been deleted.
				break
			} else {
				log.Error(err, "unable to retrieve application being deleted")
			}

		}

		backoff.DelayOnFail(ctx)
	}

	// If the Argo CD was unable to delete the application properly, then just remove the finalizer and
	// wait for it to go away (up to 2 minutes)
	if !success {

		backoff.Reset()

		// Wait 2 minutes from the current time for the application to delete, before reporting an error.
		expirationTime = time.Now().Add(WaitForArgoCDToPerformNonfinalizerDeleteTimeout)

		for {

			if time.Now().After(expirationTime) {
				log.Error(nil, "Argo CD Application finalizer was removed, but the delete wait expired in deleteArgoCDApplication")
				success = false
				break
			}

			if err := eventClient.Get(ctx, client.ObjectKeyFromObject(app), app); err != nil {

				if apierr.IsNotFound(err) {
					log.Info("The Argo CD application has been successfully deleted, after the finalizer was removed.")
					// Success! The Application (and its resources) have been deleted.
					success = true
					break
				} else {
					// A generic retrieve error occurred
					log.Error(err, "unable to retrieve Application in deleteArgoCDApplication")
					continue
				}
			} else {

				if len(app.Finalizers) != 0 {
					// If the application exists, and it has a finalizer, remove the finalizer and try again
					log.Info("removing finalizer from Application")
					app.Finalizers = []string{}
					if err := eventClient.Update(ctx, app); err != nil {
						log.Error(err, "unable to remove finalizer from Application")
						continue
					}
					sharedutil.LogAPIResourceChangeEvent(app.Namespace, app.Name, app, sharedutil.ResourceModified, log)

				}
			}

			backoff.DelayOnFail(ctx)
		}
	}

	if !success {
		log.Info("Application was not successfully deleted")
	} else {
		log.Info("Application was successfully deleted")
	}

	return nil
}

// CompareApplication compares an Argo CD Application and the spec field of a DB Application row, returning "" if the same,
// otherwise returning the specific difference.
func CompareApplication(argoCDApp appv1.Application, dbApplication db.Application, log logr.Logger) (string, error) {

	// reflect.DeepEqual will treat empty slices differently depending on how they are defined, so we ensure that
	// in every case, an empty slice is defined as a appv1.SyncOptions{}
	sanitizeApp := func(input appv1.Application) appv1.Application {
		if input.Spec.SyncPolicy != nil {

			if len(input.Spec.SyncPolicy.SyncOptions) == 0 {
				input.Spec.SyncPolicy.SyncOptions = appv1.SyncOptions{}
			}
		}
		return input
	}
	argoCDApp = sanitizeApp(*argoCDApp.DeepCopy())

	specFieldAppFromDB := appv1.Application{}

	if err := yaml.Unmarshal([]byte(dbApplication.Spec_field), &specFieldAppFromDB); err != nil {
		log.Error(err, "SEVERE: unable to unmarshal DB application spec field, on updating existing Application CR: "+argoCDApp.Name)
		// We return nil here, with no retry, because there's likely nothing else that can be done to fix this.
		// Thus there is no need to keep retrying.
		return "", nil
	}

	specFieldAppFromDB = sanitizeApp(specFieldAppFromDB)

	var specDiff string
	if !reflect.DeepEqual(specFieldAppFromDB.Spec.Source, argoCDApp.Spec.Source) {
		specDiff = "spec.source fields differ"
	} else if !reflect.DeepEqual(specFieldAppFromDB.Spec.Destination, argoCDApp.Spec.Destination) {
		specDiff = "spec.destination fields differ"
	} else if specFieldAppFromDB.Spec.Project != argoCDApp.Spec.Project {
		specDiff = "spec project fields differ"
	} else if !reflect.DeepEqual(specFieldAppFromDB.Spec.SyncPolicy, argoCDApp.Spec.SyncPolicy) {
		specDiff = "sync policy fields differ"
	}

	return specDiff, nil

}
