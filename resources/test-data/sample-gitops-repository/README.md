# GitOps Repository Template

This is an example of what the AppStudio GitOps repository might look like for a simple application. This example contains two components ('component A' and 'component B'), and two environments ('dev' and 'staging').

In particular:
- New environments should be added and removed from `environments/overlays/(environment name)`
    - K8s resources (ConfigMaps/etc) that are defined within all environment should be included in `environments/base`
    - Environments can also contain environment-specific K8s resources: they should be defined in the environment's overlay
- The GitOps repository can contain multiple components (for example, the 'frontend' and 'backend' of a single application.)
- Environment-specific component configuration should be defined in `component/(component name)/overlays/(environment name)`
    - For example, environment variables of the component that are set only in production, or only in development (eg different database credentials for different environments)
- Otherwise this repository uses the standard kustomize `base`/`overlays` pattern, where `base` contain resource definitions, and `overlays` contain patches against those resource definitions (which eliminates the need to duplicate data across multiple resources)

## Resources

There are two types of resources defined in this repository:
- **Components**: 
    - A component contains one or more Kubernetes resources (Deployments/ConfigMaps/etc), representing a component of an application to deploy.
    - For example, the 'frontend' and 'backend' of a single application (both would be components, here)
    - Component resources may be customized (by kustomize) based on the environment they are targeting, for example, different environment variables in staging/production containing different database service credentials.

- **Environments**
    - Components are deployed within environments.
    - Environments contain the list of components that are to be deployed to them. See `environments/overlays/(environment name)/kustomization.yaml` for the list of components that are to be included in a particular environment.
        - For example, if 'componentA' and 'componentB' are to be deployed to environment 'dev', then 'componentA' and 'componentB' should be referenced via in `environments/overlays/dev/kustomization.yaml`
        - In a similar fashion, it is easy to support deploying only a subset of components to an environment. For example, only 'componentA' or 'componentB'.
    - An environment may also contain zero or more Kubernetes resources (eg Deployments/ConfigMaps/etc) that should be deployed within a particular environment. (These would be resources that are not tied to a specific component, but still need to be present. For example, a `ResourceQuota` in a namespace)


## Primary Kustomize Entrypoints


**_Note_:** this has changed from an earlier version of this repository, where the entrypoint was within the application overlay.

The full contents of the GitOps repository can be generated by calling `kustomize build` on the _environment_ to deploy.

For example:
- `kustomize build environments/overlays/dev`: To generate the environment dev K8s resources, including all referenced components (eg component A/B/...), and environment-specific resources
- `kustomize build environments/overlays/staging`: To generate the environment staging K8s resources, including all referenced components (eg component A/B/...), and environment-specific resources


## Tree Diagram

Here is the hierarchy of resources within the repository:

```
.
├── environments
│   ├── base
│   │   ├── cm-env-config-map.yaml
│   │   └── kustomization.yaml
│   └── overlays
│       ├── dev
│       │   └── kustomization.yaml
│       └── staging
│           └── kustomization.yaml
└── components
    ├── componentA
    │   ├── base
    │   │   ├── deployment-sample-workload.yaml
    │   │   ├── kustomization.yaml
    │   │   ├── route-sample-workload.yaml
    │   │   └── service-sample-workload.yaml
    │   └── overlays
    │       ├── dev
    │       │   └── kustomization.yaml
    │       └── staging
    │           └── kustomization.yaml
    └── componentB
        ├── base
        │   ├── deployment-sample-workload.yaml
        │   ├── kustomization.yaml
        │   ├── route-sample-workload.yaml
        │   └── service-sample-workload.yaml
        └── overlays
            ├── dev
            │   └── kustomization.yaml
            └── staging
                └── kustomization.yaml
```



## Try it out

#### Prerequisites:
- Ensure you have `kustomize` installed, and that `kubectl` is pointing to a valid *OpenShift* cluster.

You can try it out by running the following commands:
```bash
# Dev Environment -------------------------------------------------------------

# Create the target namespace
kubectl create namespace my-environment

# Output the K8s resources that will be applied for the environment
kustomize build environments/overlays/dev

# Apply the resources (then wait a moment)
kustomize build environments/overlays/dev | kubectl apply -n my-environment -f -

# Retrieve the routes of the components
kubectl get routes

# You should now be able to access the Route, and see the environments variables output by that Route:
# example:
# https://component-a-my-environment.apps.(cluster hostname).openshift.com/env
# should contain:
# ANOTHER_ENV_VAR: another-value
# ENV_VAR_FROM_CONFIG_MAP: dev
# RESOURCE_ENVIRONMENT: dev
# (...)

# Notice that RESOURCE_ENVIRONMENT and ENV_VAR_FROM_CONFIG_MAP match the environment name, 'dev'.



# Staging Environment ---------------------------------------------------------

# Create the target namespace
kubectl create namespace my-environment

# Output the K8s resources that will be applied for the environment
kustomize build environments/overlays/staging

# Apply the resources (then wait a moment)
kustomize build environments/overlays/staging | kubectl apply -n my-environment -f -

# Retrieve the routes of the components
kubectl get routes

# You should now be able to access the Route, and see the environments variables output by that Route:
# example:
# https://component-a-my-environment.apps.(cluster hostname).openshift.com/env
# should contain:
# ANOTHER_ENV_VAR: another-value
# ENV_VAR_FROM_CONFIG_MAP: staging
# RESOURCE_ENVIRONMENT: staging
# (...)

# Notice that RESOURCE_ENVIRONMENT and ENV_VAR_FROM_CONFIG_MAP match the environment name, 'staging'.
```
